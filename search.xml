<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>装饰者模式</title>
    <url>/2020/03/19/design_patterns_decorator/</url>
    <content><![CDATA[<p>&emsp;&emsp;在学习Netty的时候，对io流，及一些常用的设计模式进行了补习。在此记录一下<strong>装饰者模式</strong>。</p>
<a id="more"></a>
<h3 id="什么是装饰者模式"><a href="#什么是装饰者模式" class="headerlink" title="什么是装饰者模式"></a>什么是装饰者模式</h3><p>&emsp;&emsp;装饰者模式，以类似“装饰”的方式，动态地给对象添加功能。装饰者模式要求装饰对象和被装饰对象同时实现同一个接口，装饰对象持有被装饰对象实例。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>&emsp;&emsp;给一个对象<strong>添加新功能</strong>，要求可以<strong>动态</strong>添加<strong>动态</strong>撤销。相较于继承，不需要新建很多子类，而且可以按功能划分不同的装饰类，动态组合，而且对于多种不同的功能要求可以自由组合地情况，根据不同的情况创建不同的子类变得不切实际，这个时候就需要装饰者模式。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KfcPlatedMeals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被装饰类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlatedMeals</span> <span class="keyword">implements</span> <span class="title">KfcPlatedMeals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlatedMeals</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">":"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>装饰类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrenchFries</span> <span class="keyword">implements</span> <span class="title">KfcPlatedMeals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> KfcPlatedMeals platedMeals;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrenchFries</span><span class="params">(KfcPlatedMeals platedMeals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.platedMeals = platedMeals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> platedMeals.getName() + <span class="string">" 薯条"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> platedMeals.getPrice() + <span class="number">11f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cola</span> <span class="keyword">implements</span> <span class="title">KfcPlatedMeals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> KfcPlatedMeals platedMeals;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cola</span><span class="params">(KfcPlatedMeals platedMeals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.platedMeals = platedMeals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> platedMeals.getName() + <span class="string">" 可乐"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> platedMeals.getPrice() + <span class="number">2.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KfcPlatedMealsTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlatedMeals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KfcPlatedMeals platedMealsA = <span class="keyword">new</span> Cola(<span class="keyword">new</span> FrenchFries(<span class="keyword">new</span> PlatedMeals(<span class="string">"套餐A"</span>)));</span><br><span class="line">        System.out.println(platedMealsA.getName() + <span class="string">" /价格："</span> + platedMealsA.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>装饰者</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot多模块项目mvn install时报错&quot;compilation failure&quot;</title>
    <url>/2019/06/30/spring_boot_maven_plugin/</url>
    <content><![CDATA[<p>&emsp;&emsp;这几天用Maven构建了一个项目，包含了几个Modules，写了一些初始化的代码后，第一次运行”mvn clean install”的时候，却报错了。。Compilation failure……</p>
<a id="more"></a>
<p>控制台报错如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:<span class="number">3.8</span><span class="number">.1</span>:compile (<span class="keyword">default</span>-compile) on project spring-bucks-data: Compilation failure: Compilation failure: </span><br><span class="line">[ERROR] /E:/workspace/spring-bucks/spring-bucks-data/src/main/java/top/dfghhj/springbucks/data/model/CoffeeOrder.java:[<span class="number">4</span>,<span class="number">46</span>] 程序包top.dfghhj.springbucks.common.constant不存在</span><br><span class="line">[ERROR] /E:/workspace/spring-bucks/spring-bucks-data/src/main/java/top/dfghhj/springbucks/data/model/CoffeeOrder.java:[<span class="number">15</span>,<span class="number">1</span>] 找不到符号</span><br><span class="line">[ERROR]   符号:   类 OrderState</span><br><span class="line">[ERROR]   位置: 类 top.dfghhj.springbucks.data.model.CoffeeOrder</span><br><span class="line">[ERROR] /E:/workspace/spring-bucks/spring-bucks-data/src/main/java/top/dfghhj/springbucks/data/model/CoffeeOrder.java:[<span class="number">16</span>,<span class="number">1</span>] 找不到符号</span><br><span class="line">[ERROR]   符号:   类 OrderState</span><br><span class="line">[ERROR]   位置: 类 top.dfghhj.springbucks.data.model.CoffeeOrder.CoffeeOrderBuilder</span><br><span class="line">[ERROR] -&gt; [Help <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>刚开始以为是不同模块之间的引用写错了，检查后发现并没有问题。这种怪异的情况第一次遇到，百思不得其解，然后就去百度了…</p>
<p>&emsp;&emsp;最后发现是pom.xml中的spring-boot-maven-plugin插件的原因，因为几个Modules都是SpringBoot的工程，通过脚手架生成出来在pom.xml中都会默认添加spring-boot-maven-plugin插件。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;spring-boot-maven-plugin的主要作用就是把项目打包成可执行的jar包。  </p>
<p>&emsp;&emsp;做个简单的实验，一个是有spring-boot-maven-plugin插件的情况下运行”mvn package”,一个是没有spring-boot-maven-plugin插件的情况下运行”mvn package”，最后查看两者打包出来的jar的结构。</p>
<p>有spring-boot-maven-plugin插件情况下：<br><img src="/2019/06/30/spring_boot_maven_plugin/1.png" alt="1">  </p>
<p>没有spring-boot-maven-plugin插件情况下：<br><img src="/2019/06/30/spring_boot_maven_plugin/2.png" alt="2">  </p>
<p>&emsp;&emsp;对比了jar包的结构，基本可以确定就是spring-boot-maven-plugin插件的原因。spring-boot-maven-plugin插件打包后所有的包和类都放到了BOOT-INF文件夹中，而一般方式打包出来的包和类都在根路径下面。解决方案有二：</p>
<p>1.如果不需通过运行jar来启动程序的话，可以把spring-boot-maven-plugin插件删除，使用maven默认的打包方式；</p>
<p>2.修改spring-boot-maven-plugin插件配置项： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;classifier&gt;exec&lt;/classifier&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<p>“<classifier>exec</classifier>“的作用是为spring-boot-maven-plugin打出来的jar包添加”exec”后缀以区分两个不同的jar包。</p>
<p>参考：</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/howto-build.html#howto-create-a-nonexecutable-jar" target="_blank" rel="noopener">Spring Boot Reference Guide</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/maven-plugin/examples/repackage-classifier.html" target="_blank" rel="noopener">Spring Boot Maven Plugin</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>maven</category>
      </categories>
      <tags>
        <tag>填坑日记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的静态代理与动态代理</title>
    <url>/2019/06/21/proxy/</url>
    <content><![CDATA[<p>&emsp;&emsp;代理模式为一个对象提供一个代理对象来控制对这个对象的访问。所谓代理（Proxy），就是代表某个真实的对象。<br>&emsp;&emsp;代理分为静态代理和动态代理。静态代理是在编译时就将接口、实现类、代理类全部手动完成；动态代理可以在程序运行期间根据需要动态的创建代理类及其实例，来完成具体的功能。</p>
<a id="more"></a>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>&emsp;&emsp;首先创建一个接口，然后创建具体实现类来实现这个接口，再创建一个代理类同样实现这个接口，不同之处在于，具体实现类中的方法需要将业务逻辑功能实现，而代理类中的方法只需要调用具体类中的对应方法，这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可。类图图下所示。</p>
<p><img src="/2019/06/21/proxy/静态代理.png" alt="静态代理"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>1.定义接口Subject<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.创建具体实现类RealSubject<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Named "</span> + name);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.创建代理类SubjectProxy<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setName --- 前置操作"</span>);</span><br><span class="line">        subject.setName(name);</span><br><span class="line">        System.out.println(<span class="string">"setName --- 后置操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName --- 前置操作"</span>);</span><br><span class="line">        String name = subject.getName();</span><br><span class="line">        System.out.println(<span class="string">"getName --- 后置操作"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.测试<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> ProxySubject();</span><br><span class="line">        subject.setName(<span class="string">"大大"</span>);</span><br><span class="line">        System.out.println(<span class="string">"================="</span>);</span><br><span class="line">        subject.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.运行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setName --- 前置操作</span><br><span class="line">Named 大大</span><br><span class="line">setName --- 后置操作</span><br><span class="line">=================</span><br><span class="line">getName --- 前置操作</span><br><span class="line">Name is 大大</span><br><span class="line">getName --- 后置操作</span><br></pre></td></tr></table></figure></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>&emsp;&emsp;在静态代理中，一个代理只能代理一种类型，而且是在编译时就已经确定被代理的对象。而动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。<br>&emsp;&emsp;在Java中要想实现动态代理机制，需要java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy 类的支持。类图图下所示。</p>
<p><img src="/2019/06/21/proxy/动态代理.png" alt="动态代理"></p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>1.定义接口Subject<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSports</span><span class="params">(String SportName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.创建具体实现类RealSubject<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSports</span><span class="params">(String sportName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始："</span> + sportName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.创建实现InvocationHandler接口的代理类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaygroundInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String canDo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlaygroundInvocationHandler</span><span class="params">(Object object, String canDo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        <span class="keyword">this</span>.canDo = canDo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String willDo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            willDo = (String) args[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canDo.equals(willDo)) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(object, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"该场地不允许"</span> + willDo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.测试<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        InvocationHandler bc = <span class="keyword">new</span> PlaygroundInvocationHandler(subject, <span class="string">"打篮球"</span>);</span><br><span class="line">        Subject bcProxy = (Subject) Proxy.newProxyInstance(subject.getClass().getClassLoader(),</span><br><span class="line">                subject.getClass().getInterfaces(),</span><br><span class="line">                bc);</span><br><span class="line">        bcProxy.doSports(<span class="string">"打篮球"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bcProxy.doSports(<span class="string">"踢足球"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"========================="</span>);</span><br><span class="line">        InvocationHandler ff = <span class="keyword">new</span> PlaygroundInvocationHandler(subject, <span class="string">"踢足球"</span>);</span><br><span class="line">        Subject ffProxy = (Subject) Proxy.newProxyInstance(subject.getClass().getClassLoader(),</span><br><span class="line">                subject.getClass().getInterfaces(),</span><br><span class="line">                ff);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ffProxy.doSports(<span class="string">"打篮球"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        ffProxy.doSports(<span class="string">"踢足球"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.运行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始：打篮球</span><br><span class="line">该场地不允许踢足球</span><br><span class="line">=========================</span><br><span class="line">该场地不允许打篮球</span><br><span class="line">开始：踢足球</span><br></pre></td></tr></table></figure></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/Dfghhj/ProxyDemo" target="_blank" rel="noopener">Proxy Demo</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Head First设计模式(中文版)》第11章</li>
<li><a href="https://www.cnblogs.com/V1haoge/p/5860749.html" target="_blank" rel="noopener">java静态代理与动态代理简单分析</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
</search>
